"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9676],{9291:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>c,metadata:()=>d,toc:()=>u});var a=t(5773),s=(t(7378),t(5318));const o='import { OpenAI } from "langchain/llms";\nimport { loadQAStuffChain, loadQAMapReduceChain } from "langchain/chains";\nimport { Document } from "langchain/document";\n\nexport const run = async () => {\n  // This first example uses the `StuffDocumentsChain`.\n  const llmA = new OpenAI({});\n  const chainA = loadQAStuffChain(llmA);\n  const docs = [\n    new Document({ pageContent: "Harrison went to Harvard." }),\n    new Document({ pageContent: "Ankush went to Princeton." }),\n  ];\n  const resA = await chainA.call({\n    input_documents: docs,\n    question: "Where did Harrison go to college?",\n  });\n  console.log({ resA });\n  // { resA: { text: \' Harrison went to Harvard.\' } }\n\n  // This second example uses the `MapReduceChain`.\n  // Optionally limit the number of concurrent requests to the language model.\n  const llmB = new OpenAI({ maxConcurrency: 10 });\n  const chainB = loadQAMapReduceChain(llmB);\n  const resB = await chainB.call({\n    input_documents: docs,\n    question: "Where did Harrison go to college?",\n  });\n  console.log({ resB });\n  // { resB: { text: \' Harrison went to Harvard.\' } }\n};\n';var i=t(6538);const c={},r="Document QA Chains",d={unversionedId:"modules/chains/index_related_chains/document_qa",id:"modules/chains/index_related_chains/document_qa",title:"Document QA Chains",description:"LangChain provides chains used for processing unstructured text data: StuffDocumentsChain and MapReduceDocumentsChain.",source:"@site/docs/modules/chains/index_related_chains/document_qa.mdx",sourceDirName:"modules/chains/index_related_chains",slug:"/modules/chains/index_related_chains/document_qa",permalink:"/langchainjs/docs/modules/chains/index_related_chains/document_qa",draft:!1,editUrl:"https://github.com/hwchase17/langchainjs/docs/modules/chains/index_related_chains/document_qa.mdx",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"ConversationalRetrievalQAChain",permalink:"/langchainjs/docs/modules/chains/index_related_chains/conversational_retrieval"},next:{title:"RetrievalQAChain",permalink:"/langchainjs/docs/modules/chains/index_related_chains/retrieval_qa"}},l={},u=[],h={toc:u},m="wrapper";function p(n){let{components:e,...t}=n;return(0,s.kt)(m,(0,a.Z)({},h,t,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"document-qa-chains"},"Document QA Chains"),(0,s.kt)("p",null,"LangChain provides chains used for processing unstructured text data: ",(0,s.kt)("inlineCode",{parentName:"p"},"StuffDocumentsChain")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"MapReduceDocumentsChain"),".\nThese chains are the building blocks more complex chains for processing unstructured text data and receive both documents and a question as input. They then utilize the language model to provide an answer to the question based on the given documents."),(0,s.kt)(i.Z,{language:"typescript",mdxType:"CodeBlock"},o))}p.isMDXComponent=!0}}]);