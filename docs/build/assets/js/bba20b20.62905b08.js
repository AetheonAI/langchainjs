"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5247],{3305:(n,e,a)=>{a.r(e),a.d(e,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>s,metadata:()=>h,toc:()=>k});var t=a(5773),o=(a(7378),a(5318)),l=a(6538);const r='import { CallbackManager, ConsoleCallbackHandler } from "langchain/callbacks";\nimport { OpenAI, PromptTemplate, LLMChain } from "langchain";\n\nexport const run = async () => {\n  const callbackManager = new CallbackManager();\n  callbackManager.addHandler(new ConsoleCallbackHandler());\n\n  const llm = new OpenAI({ temperature: 0, callbackManager });\n  const prompt = PromptTemplate.fromTemplate("1 + {number} =");\n  const chain = new LLMChain({ prompt, llm, callbackManager });\n\n  await chain.call({ number: 2 });\n  /*\n  Entering new llm_chain chain...\n  Finished chain.\n  */\n};\n',i="import { LLMChain } from \"langchain\";\nimport { AgentExecutor, ZeroShotAgent } from \"langchain/agents\";\nimport { CallbackManager } from \"langchain/callbacks\";\nimport { ChatOpenAI } from \"langchain/chat_models\";\nimport { Calculator } from \"langchain/tools\";\n\nexport const run = async () => {\n  // Create a callback manager that will be used throughout\n  const callbackManager = CallbackManager.fromHandlers({\n    async handleLLMNewToken(token: string) {\n      console.log(\"token\", { token });\n    },\n    async handleLLMStart(llm, _prompts: string[]) {\n      console.log(\"handleLLMStart\", { llm });\n    },\n    async handleChainStart(chain) {\n      console.log(\"handleChainStart\", { chain });\n    },\n    async handleAgentAction(action) {\n      console.log(\"handleAgentAction\", action);\n    },\n    async handleToolStart(tool) {\n      console.log(\"handleToolStart\", { tool });\n    },\n  });\n\n  const model = new ChatOpenAI({\n    temperature: 0,\n    callbackManager, // this is needed to see handleLLMStart and handleLLMNewToken\n    streaming: true, // needed to enable streaming, which enables handleLLMNewToken\n  });\n\n  const tools = [\n    new Calculator(\n      true,\n      callbackManager /* this is needed to see handleToolStart */\n    ),\n  ];\n  const agentPrompt = ZeroShotAgent.createPrompt(tools);\n  const llmChain = new LLMChain({\n    llm: model,\n    prompt: agentPrompt,\n    callbackManager, // this is needed to see handleChainStart\n  });\n  const agent = new ZeroShotAgent({\n    llmChain,\n    allowedTools: [\"search\"],\n  });\n\n  const agentExecutor = AgentExecutor.fromAgentAndTools({\n    agent,\n    tools,\n    callbackManager, // this is needed to see handleAgentAction\n  });\n\n  const result = await agentExecutor.call({\n    input: \"What is 2 to the power of 8\",\n  });\n  /*\n  handleChainStart { chain: { name: 'agent_executor' } }\n  handleChainStart { chain: { name: 'llm_chain' } }\n  handleLLMStart { llm: { name: 'openai' } }\n  token { token: '' }\n  token { token: 'I' }\n  token { token: ' need' }\n  token { token: ' to' }\n  token { token: ' calculate' }\n  token { token: ' ' }\n  token { token: '2' }\n  token { token: ' raised' }\n  token { token: ' to' }\n  token { token: ' the' }\n  token { token: ' power' }\n  token { token: ' of' }\n  token { token: ' ' }\n  token { token: '8' }\n  token { token: '\\n' }\n  token { token: 'Action' }\n  token { token: ':' }\n  token { token: ' calculator' }\n  token { token: '\\n' }\n  token { token: 'Action' }\n  token { token: ' Input' }\n  token { token: ':' }\n  token { token: ' ' }\n  token { token: '2' }\n  token { token: '^' }\n  token { token: '8' }\n  token { token: '' }\n  handleAgentAction {\n    tool: 'calculator',\n    toolInput: '2^8',\n    log: 'I need to calculate 2 raised to the power of 8\\n' +\n      'Action: calculator\\n' +\n      'Action Input: 2^8'\n  }\n  handleToolStart { tool: { name: 'calculator' } }\n  handleChainStart { chain: { name: 'llm_chain' } }\n  handleLLMStart { llm: { name: 'openai' } }\n  token { token: '' }\n  token { token: 'That' }\n  token { token: \"'s\" }\n  token { token: ' the' }\n  token { token: ' answer' }\n  token { token: ' to' }\n  token { token: ' the' }\n  token { token: ' question' }\n  token { token: '\\n' }\n  token { token: 'Final' }\n  token { token: ' Answer' }\n  token { token: ':' }\n  token { token: ' ' }\n  token { token: '256' }\n  token { token: '' }\n  */\n\n  console.log(result);\n  /*\n  { output: '256' }\n  */\n};\n",s={},c="Events / Callbacks",h={unversionedId:"production/callbacks",id:"production/callbacks",title:"Events / Callbacks",description:"LangChain provides a callback system that allows you to hook into the various stages of your LLM application. This is useful for logging, monitoring, streaming, and other tasks.",source:"@site/docs/production/callbacks.mdx",sourceDirName:"production",slug:"/production/callbacks",permalink:"/langchainjs/docs/production/callbacks",draft:!1,editUrl:"https://github.com/hwchase17/langchainjs/docs/production/callbacks.mdx",tags:[],version:"current",frontMatter:{},sidebar:"sidebar",previous:{title:"Summarization",permalink:"/langchainjs/docs/use_cases/summarization"},next:{title:"Deployment",permalink:"/langchainjs/docs/production/deployment"}},d={},k=[{value:"Using an existing handler",id:"using-an-existing-handler",level:2},{value:"Creating a one-off handler",id:"creating-a-one-off-handler",level:2},{value:"Creating a custom handler",id:"creating-a-custom-handler",level:2}],g={toc:k},p="wrapper";function m(n){let{components:e,...a}=n;return(0,o.kt)(p,(0,t.Z)({},g,a,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"events--callbacks"},"Events / Callbacks"),(0,o.kt)("p",null,"LangChain provides a callback system that allows you to hook into the various stages of your LLM application. This is useful for logging, ",(0,o.kt)("a",{parentName:"p",href:"./tracing"},"monitoring"),", ",(0,o.kt)("a",{parentName:"p",href:"../modules/models/llms/additional_functionality#streaming-responses"},"streaming"),", and other tasks."),(0,o.kt)("p",null,"You can subscribe to these events by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"callbackManager")," argument available throughout the API. A ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackManager")," is an object that manages a list of ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackHandlers"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackManager")," will call the appropriate method on each handler when the event is triggered."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"interface CallbackManager {\n  addHandler(handler: CallbackHandler): void;\n\n  removeHandler(handler: CallbackHandler): void;\n\n  setHandlers(handlers: CallbackHandler[]): void;\n\n  setHandler(handler: CallbackHandler): void;\n}\n")),(0,o.kt)("p",null,"CallbackHandlers are objects that implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackHandler")," interface, which has a method for each event that can be subscribed to. The ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackManager")," will call the appropriate method on each handler when the event is triggered."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"abstract class BaseCallbackHandler {\n  handleLLMStart?(\n    llm: { name: string },\n    prompts: string[],\n    verbose?: boolean\n  ): Promise<void>;\n\n  handleLLMNewToken?(token: string, verbose?: boolean): Promise<void>;\n\n  handleLLMError?(err: Error, verbose?: boolean): Promise<void>;\n\n  handleLLMEnd?(output: LLMResult, verbose?: boolean): Promise<void>;\n\n  handleChainStart?(\n    chain: { name: string },\n    inputs: ChainValues,\n    verbose?: boolean\n  ): Promise<void>;\n\n  handleChainError?(err: Error, verbose?: boolean): Promise<void>;\n\n  handleChainEnd?(outputs: ChainValues, verbose?: boolean): Promise<void>;\n\n  handleToolStart?(\n    tool: { name: string },\n    input: string,\n    verbose?: boolean\n  ): Promise<void>;\n\n  handleToolError?(err: Error, verbose?: boolean): Promise<void>;\n\n  handleToolEnd?(output: string, verbose?: boolean): Promise<void>;\n\n  handleText?(text: string, verbose?: boolean): Promise<void>;\n\n  handleAgentAction?(action: AgentAction, verbose?: boolean): Promise<void>;\n\n  handleAgentEnd?(action: AgentFinish, verbose?: boolean): Promise<void>;\n}\n")),(0,o.kt)("h2",{id:"using-an-existing-handler"},"Using an existing handler"),(0,o.kt)("p",null,"LangChain provides a few built-in handlers that you can use to get started. These are available in the ",(0,o.kt)("inlineCode",{parentName:"p"},"langchain/callbacks")," module. The most basic handler is the ",(0,o.kt)("inlineCode",{parentName:"p"},"ConsoleCallbackHandler"),", which simply logs all events to the console. In the future we will add more default handlers to the library."),(0,o.kt)(l.Z,{language:"typescript",mdxType:"CodeBlock"},r),(0,o.kt)("h2",{id:"creating-a-one-off-handler"},"Creating a one-off handler"),(0,o.kt)("p",null,"We offer a method on the ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackManager")," class that allows you to create a one-off handler. This is useful if eg. you need to create a handler that you will use only for a single request, eg to stream the output of an LLM/Agent/etc to a websocket."),(0,o.kt)("p",null,"This is a more complete example that passes a ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackManager")," to a ChatModel, and LLMChain, a Tool, and an Agent."),(0,o.kt)(l.Z,{language:"typescript",mdxType:"CodeBlock"},i),(0,o.kt)("h2",{id:"creating-a-custom-handler"},"Creating a custom handler"),(0,o.kt)("p",null,"You can also create your own handler by implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"CallbackHandler")," interface. This is useful if you want to do something more complex than just logging to the console, eg. send the events to a logging service. As an example here is the implementation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ConsoleCallbackHandler"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},'export class MyCallbackHandler extends BaseCallbackHandler {\n  async handleChainStart(chain: { name: string }) {\n    console.log(`Entering new ${chain.name} chain...`);\n  }\n\n  async handleChainEnd(_output: ChainValues) {\n    console.log("Finished chain.");\n  }\n\n  async handleAgentAction(action: AgentAction) {\n    console.log(action.log);\n  }\n\n  async handleToolEnd(output: string) {\n    console.log(output);\n  }\n\n  async handleText(text: string) {\n    console.log(text);\n  }\n\n  async handleAgentEnd(action: AgentFinish) {\n    console.log(action.log);\n  }\n}\n')),(0,o.kt)("p",null,"You could then use it as described in the ",(0,o.kt)("a",{parentName:"p",href:"#using-an-existing-handler"},"section")," above."))}m.isMDXComponent=!0}}]);